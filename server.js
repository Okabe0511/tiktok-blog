import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import express from 'express'
import multer from 'multer'
import 'dotenv/config' // Load environment variables
import { createServer as createViteServer } from 'vite'
import sequelize from './db/db.js'
import { Article, Comment } from './db/models.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

async function createServer() {
  const app = express()
  app.use(express.json())

  // Serve uploaded files
  app.use('/uploads', express.static(path.resolve(__dirname, 'uploads')))

  // Configure Multer for file uploads
  const storage = multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, path.resolve(__dirname, 'uploads'))
    },
    filename: function (req, file, cb) {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)
      cb(null, uniqueSuffix + path.extname(file.originalname))
    }
  })
  const upload = multer({ storage: storage })

  // --- API Routes ---
  const router = express.Router()

  // Upload Image API
  router.post('/upload', upload.single('image'), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' })
    }
    const fileUrl = `/uploads/${req.file.filename}`
    res.json({ url: fileUrl })
  })

  // Get all articles (with pagination and sorting)
  router.get('/articles', async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1
      const limit = parseInt(req.query.limit) || 10
      const offset = (page - 1) * limit
      const sortBy = req.query.sortBy || 'createdAt'
      const order = req.query.order || 'DESC'

      const { count, rows } = await Article.findAndCountAll({
        order: [[sortBy, order]],
        limit: limit,
        offset: offset
      })
      
      res.json({
        total: count,
        totalPages: Math.ceil(count / limit),
        currentPage: page,
        articles: rows
      })
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // Get article by ID
  router.get('/articles/:id', async (req, res) => {
    try {
      const article = await Article.findByPk(req.params.id)
      if (article) {
        // Increment views
        article.views += 1
        await article.save()
        res.json(article)
      } else {
        res.status(404).json({ error: 'Not found' })
      }
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // Create article
  router.post('/articles', async (req, res) => {
    try {
      const article = await Article.create(req.body)
      res.json(article)
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // Update article
  router.put('/articles/:id', async (req, res) => {
    try {
      const article = await Article.findByPk(req.params.id)
      if (article) {
        await article.update(req.body)
        res.json(article)
      } else {
        res.status(404).json({ error: 'Not found' })
      }
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // Delete article
  router.delete('/articles/:id', async (req, res) => {
    try {
      const article = await Article.findByPk(req.params.id)
      if (article) {
        await article.destroy()
        res.json({ success: true })
      } else {
        res.status(404).json({ error: 'Not found' })
      }
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // AI Writing Assistant (Mock)
  router.post('/ai/generate', async (req, res) => {
    const { prompt } = req.body
    
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    const mockResponse = `[Mock AI] Here is a generated paragraph about "${prompt}". This is a simulated response because the real AI API is currently disabled. In a real scenario, this text would be generated by a large language model based on your input.`;
    
    res.json({ content: mockResponse })
  })

  // --- Comments API ---
  router.get('/articles/:id/comments', async (req, res) => {
    try {
      const comments = await Comment.findAll({
        where: { articleId: req.params.id },
        order: [['createdAt', 'DESC']]
      })
      res.json(comments)
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  router.post('/articles/:id/comments', async (req, res) => {
    try {
      const comment = await Comment.create({
        ...req.body,
        articleId: req.params.id
      })
      res.json(comment)
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  // --- Tags API ---
  router.get('/tags', async (req, res) => {
    try {
      const articles = await Article.findAll({ attributes: ['tags'] })
      const tagCounts = {}
      articles.forEach(article => {
        if (article.tags) {
          article.tags.split(',').forEach(tag => {
            const t = tag.trim()
            if (t) {
              tagCounts[t] = (tagCounts[t] || 0) + 1
            }
          })
        }
      })
      // Convert to array
      const tags = Object.keys(tagCounts).map(tag => ({ name: tag, count: tagCounts[tag] }))
      res.json(tags)
    } catch (e) {
      res.status(500).json({ error: e.message })
    }
  })

  app.use('/api', router)

  // --- SSR Setup ---
  let vite
  const isProd = process.env.NODE_ENV === 'production'

  if (!isProd) {
    vite = await createViteServer({
      server: { middlewareMode: true },
      appType: 'custom'
    })
    app.use(vite.middlewares)
  } else {
    app.use(express.static(path.resolve(__dirname, 'dist/client'), { index: false }))
  }

  app.use('*', async (req, res) => {
    const url = req.originalUrl

    try {
      let template, render
      if (!isProd) {
        template = fs.readFileSync(path.resolve(__dirname, 'index.html'), 'utf-8')
        template = await vite.transformIndexHtml(url, template)
        render = (await vite.ssrLoadModule('/src/entry-server.js')).render
      } else {
        template = fs.readFileSync(path.resolve(__dirname, 'dist/client/index.html'), 'utf-8')
        render = (await import('./dist/server/entry-server.js')).render
      }

      const { html } = await render(url)
      const appHtml = template.replace(`<!--app-html-->`, html)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(appHtml)
    } catch (e) {
      !isProd && vite.ssrFixStacktrace(e)
      console.log(e.stack)
      res.status(500).end(e.stack)
    }
  })

  // Initialize DB and start server
  // Note: In a real app, ensure DB is ready before starting
  // We'll assume db/init.js is run separately or we can import it here
  // For now, let's just start listening
  app.listen(3000, () => {
    console.log('Server started at http://localhost:3000')
  })
}

createServer()
